import { ComponentInstance, SubscribeToCompositionOptions } from '@uniformdev/canvas';
import { Key, ReactNode } from 'react';

/**
 * Props passed to a Canvas component implementation.
 * TProps is the Canvas component's parameters object after
 * all enhancers have been applied.
 */
declare type ComponentProps<TProps = unknown> = TProps & {
    component: ComponentInstance;
};
/**
 * Function that maps a Canvas component instance to its React component to render it.
 * The resolver would commonly inspect the `type` and possibly `variant` of the component to decide.
 */
declare type RenderComponentResolver = (component: ComponentInstance) => React.ComponentType<ComponentProps<any>> | null;
/** Function that renders Canvas system internals */
declare type SystemRenderFunction = (component: ComponentInstance, key: Key, renderChild: (component: ComponentInstance, key: Key) => JSX.Element | null) => JSX.Element | null;
/** Configures rendering of system components (tests, pz) */
declare type SystemRenderConfig = {
    test: SystemRenderFunction;
    personalization: SystemRenderFunction;
};

declare type CompositionProps<TRenderProps = unknown> = {
    /** The root component in the composition */
    data: ComponentInstance;
    /** Resolves a React component to render a Canvas component, generally by inspecting type/variant */
    resolveRenderer?: RenderComponentResolver;
    /** Either markup to render the composition directly, or render props to provide the ComponentProps for the root component */
    children: ReactNode | ((props: ComponentProps<TRenderProps>) => JSX.Element);
    /**
     * When to track behavior from enrichment tags on this composition
     * onView: adds enrichment score when the visitor views the tagged component in the browser viewport.
     * onLoad: adds enrichment score as soon as the composition mounts, regardless of viewport.
     *
     * NOTE: onView renders a <div> tag around components that have enrichment tags, to support IntersectionObserver.
     * onLoad does not need to do this, and renders no wrapping tag.
     *
     * Default: onView
     */
    behaviorTracking?: 'onLoad' | 'onView';
};
declare type CompositionContext = {
    /** The parent composition */
    composition: ComponentInstance;
    /** The current function to translate component data into React components */
    resolveRenderer?: RenderComponentResolver;
    behaviorTracking: 'onLoad' | 'onView';
};
/**
 * Gets the parent Canvas composition of the current component.
 * Note: this gets the direct parent, not necessarily the root of the composition.
 */
declare function useComposition(): CompositionContext | undefined;
/** Forms a Canvas composition root, providing services to render a tree of Canvas components */
declare function Composition<TRenderProps = unknown>({ data, resolveRenderer, children, behaviorTracking, }: CompositionProps<TRenderProps>): JSX.Element | null;

declare type CustomSlotChildRenderFunc = (options: {
    child: ReactNode;
    component: ComponentInstance;
    key: Key;
}) => JSX.Element;
declare type SlotProps<TSlotNames extends string> = {
    /** Name of the slot to render */
    name: TSlotNames;
    /**
     * Function to resolve the React component to render for a given Canvas component type.
     * If not specified, the resolveRenderer function on the nearest Layout will be used, if any.
     */
    resolveRenderer?: RenderComponentResolver;
    /** Optional render props enables wrapping all child components in the slot with some markup */
    children?: CustomSlotChildRenderFunc;
};
/** Renders a named Slot within a Composition. */
declare function Slot<TSlotNames extends string = string>({ name, resolveRenderer, children, }: SlotProps<TSlotNames>): JSX.Element | null;

/**
 * A default implementation of a component-not-implemented component.
 * Useful for model-first workflows where frontend dev comes later.
 * To make this work, it needs to be the default returned from the
 * resolveRenderer() function when the component is unknown.
 **/
declare function DefaultNotImplementedComponent(props: ComponentProps): JSX.Element | null;

declare type UseCompositionEventEffectOptions = Omit<Partial<SubscribeToCompositionOptions>, 'callback'> & {
    enabled: boolean;
    effect: () => void;
};
/** Hook to manage a subscription to a realtime event on a composition */
declare function useCompositionEventEffect({ enabled, projectId, compositionId, effect, }: UseCompositionEventEffectOptions): void;

export { ComponentProps, Composition, CompositionContext, CompositionProps, DefaultNotImplementedComponent, RenderComponentResolver, Slot, SlotProps, SystemRenderConfig, SystemRenderFunction, UseCompositionEventEffectOptions, useComposition, useCompositionEventEffect };
