import { Change } from 'diff';
import { Argv } from 'yargs';

declare type SyncEngineLogOptions = {
    id: string;
    providerId: string;
    displayName: string;
    action: 'create' | 'update' | 'delete';
    whatIf: boolean;
    diff: Change[];
};
declare type SyncEngineObject<TObject> = {
    /** Unique ID that is identical across all providers */
    id: string;
    /** Provider specific ID. Value is provided to deleteObject() function (always the provider ID from the same provider that issued it). */
    providerId: string;
    /** Optional display name of the object for log messages. The providerId will be used if this is not set. */
    displayName?: string;
    /** The object being synced. */
    object: TObject;
};
declare type SyncEngineDataSource<TObject> = {
    /** The objects to sync. */
    objects: AsyncIterable<SyncEngineObject<TObject>>;
    /**
     * Called when the sync engine detects a need to update a synced object.
     * Only called if this source is the target of a sync operation.
     * @param obj The object to write to the data source
     * @param existingObj The existing object that matches this one in the data source (if any)
     */
    writeObject: (obj: SyncEngineObject<TObject>, existingObj?: SyncEngineObject<TObject>) => Promise<void>;
    /**
     * Called when the sync engine detects a need to delete an object in this data source.
     * Only called if this source is the target of a sync operation.
     */
    deleteObject: (providerId: string) => Promise<void>;
    /**
     * Called when the sync engine finishes synchronization.
     */
    onSyncComplete?: (isTarget: boolean) => Promise<void>;
};
declare type SyncEngineOptions<TObject> = {
    source: SyncEngineDataSource<TObject>;
    target: SyncEngineDataSource<TObject>;
    compareContents?: (source: SyncEngineObject<TObject>, target: SyncEngineObject<TObject>) => boolean;
    mode: 'mirror' | 'createOrUpdate' | 'create';
    /** Compare sources, but do not execute actions */
    whatIf?: boolean;
    /** An exception will normally br thrown if the sync source has nothing in it; this option allows the sync to continue (potentially deleting everything in the target) */
    allowEmptySource?: boolean;
    log?: (options: SyncEngineLogOptions) => void;
};
declare function syncEngine<TObject>({ source, target, compareContents, mode, allowEmptySource, whatIf, log, }: SyncEngineOptions<TObject>): Promise<void>;
declare class SyncEngineError<TObject> extends Error {
    constructor(innerError: unknown, sourceObject: SyncEngineObject<TObject>);
}

declare type CreateArraySyncEngineDataSourceOptions<TObject> = {
    objects: Array<TObject>;
    selectIdentifier: (object: TObject) => string;
    selectDisplayName?: (object: TObject) => string;
    onSyncComplete?: (isTarget: boolean, result: Array<TObject>) => Promise<void>;
};
declare function createArraySyncEngineDataSource<TObject>({ objects, selectIdentifier, selectDisplayName, onSyncComplete, }: CreateArraySyncEngineDataSourceOptions<TObject>): Promise<SyncEngineDataSource<TObject> & {
    extractCurrent: () => Array<TObject>;
}>;

declare type CreateFileSyncEngineDataSourceOptions<TObject> = {
    directory: string;
    selectIdentifier: (object: TObject) => string;
    selectDisplayName?: (object: TObject) => string;
    selectFilename?: (object: TObject) => string;
    format?: 'json' | 'yaml';
};
declare function createFileSyncEngineDataSource<TObject>({ directory, format, selectIdentifier, selectDisplayName, }: CreateFileSyncEngineDataSourceOptions<TObject>): Promise<SyncEngineDataSource<TObject>>;

declare type UniformPackage = {
    [key: string]: unknown;
};
declare function readUniformPackage(filename: string, assertExists: boolean): UniformPackage;
declare function writeUniformPackage(filename: string, packageContents: UniformPackage): void;

declare type DiffMode = 'off' | 'on' | 'update';
declare function createSyncEngineConsoleLogger(options?: {
    diffMode?: DiffMode;
    indent?: string;
    prefix?: string;
}): ({ action, displayName, whatIf, diff }: SyncEngineLogOptions) => void;

declare type ApiArgs = {
    apiKey: string;
    apiHost: string;
};
declare function withApiOptions<T>(yargs: Argv<T>): Argv<T>;
declare type ProjectArgs = {
    project: string;
};
declare function withProjectOptions<T>(yargs: Argv<T>): Argv<T>;
declare type FormatArgs = {
    format: 'json' | 'yaml';
    filename?: string;
};
declare function withFormatOptions<T>(yargs: Argv<T>): Argv<T>;
declare type DiffArgs = {
    diff: DiffMode;
};
declare function withDiffOptions<T>(yargs: Argv<T>): Argv<T>;
declare function isPathAPackageFile(path: string): boolean;
declare function emitWithFormat(object: any, format?: string, filename?: string): void;
declare function readFileToObject<T = unknown>(filename: string): T;
declare function paginateAsync<TResult>(fetchPage: (offset: number, limit: number) => Promise<TResult[]>, options: {
    pageSize: number;
}): AsyncIterableIterator<TResult>;

export { ApiArgs, CreateArraySyncEngineDataSourceOptions, CreateFileSyncEngineDataSourceOptions, DiffArgs, DiffMode, FormatArgs, ProjectArgs, SyncEngineDataSource, SyncEngineError, SyncEngineLogOptions, SyncEngineObject, SyncEngineOptions, UniformPackage, createArraySyncEngineDataSource, createFileSyncEngineDataSource, createSyncEngineConsoleLogger, emitWithFormat, isPathAPackageFile, paginateAsync, readFileToObject, readUniformPackage, syncEngine, withApiOptions, withDiffOptions, withFormatOptions, withProjectOptions, writeUniformPackage };
