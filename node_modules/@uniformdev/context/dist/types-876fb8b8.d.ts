import { c as components, e as external } from './v2-manifest.swagger-ff2af13e.js';
import * as mitt from 'mitt';

declare type StorageCommand<TID extends string = string, TData = unknown> = {
    type: TID;
    data: TData;
};
/** Commands that can be issued to alter the storage of Uniform Context data */
declare type StorageCommands = ModifyScoreCommand | ModifySessionScoreCommand | SetConsentCommand | SetQuirkCommand | SetTestCommand | IdentifyCommand | SetControlGroupCommand;
/**
 * Changes the visitor's permanent score for a given dimension
 */
declare type ModifyScoreCommand = StorageCommand<'modscore', {
    dimension: string;
    delta: number;
}>;
/**
 * Changes the visitor's session (time-based) score for a given dimension
 */
declare type ModifySessionScoreCommand = StorageCommand<'modscoreS', {
    dimension: string;
    delta: number;
}>;
/**
 * Changes the visitor's storage consent setting.
 * Setting consent to false will trigger deletion of any stored data for the visitor.
 * Scores are still collected in-memory when consent is false; just not persisted.
 */
declare type SetConsentCommand = StorageCommand<'consent', boolean>;
/** Sets a permanent quirk key and value for the visitor */
declare type SetQuirkCommand = StorageCommand<'setquirk', {
    key: string;
    value: string;
}>;
/** Sets a specific variant as being this visitor's variant on an A/B test */
declare type SetTestCommand = StorageCommand<'settest', {
    test: string;
    variant: string;
}>;
/**
 * Identifies the visitor as being a specific unique identifier.
 * NOTE: this only has an effect when using an external cross-device transition storage system.
 * NOTE: you cannot read the identified visitor ID back from the storage system once it is set.
 */
declare type IdentifyCommand = StorageCommand<'identify', {
    identity: string;
}>;
/**
 * Sets whether the current visitor is in the personalization control group
 * (Will not be exposed to personalization or gather classification data; WILL see A/B tests)
 * In most cases this should not be sent as the membership is computed automatically for visitors;
 * this command is intended mostly for diagnostics and testing purposes.
 */
declare type SetControlGroupCommand = StorageCommand<'setcontrol', boolean>;

declare type Quirks = {
    [key: string]: string;
};
declare type Tests = {
    [key: string]: string;
};
declare type ScoreVector = {
    [key: string]: number;
};
declare type EnrichmentData = {
    /** Enrichment category name */
    cat: string;
    /** Enrichment key value */
    key: string;
    /** Strength value (amount of score added when viewing content) */
    str: number;
};
/** An event that has occurred (i.e. an analytics track) which may trigger an Event signal */
declare type EventData = {
    /** The event name that has been fired */
    event: string;
};
declare type VisitorData = {
    /**
     * Quirk key-value data.
     * NOTE: Context.quirks is more commonly correct if you need to read quirks data.
     */
    quirks: Quirks;
    /** A/B test variant selections */
    tests: Tests;
    /**
     * Personalization score data for the current session (merge with all time for totals)
     * NOTE: Context.scores is more commonly correct to read scores instead of this value.
     */
    sessionScores: ScoreVector;
    /**
     * Personalization score data for all time (merge with session for totals)
     * NOTE: Context.scores is more commonly correct to read scores instead of this value.
     */
    scores: ScoreVector;
    /**
     * Whether consent has been given to store the visitor data
     * If false or not set: visitor data is stored in memory and is lost if the browser refreshes
     * If true: visitor data is stored in localStorage and any other transition storage if registered
     */
    consent?: boolean;
    /**
     * Whether the visitor has been assigned to the personalization control group -
     * visitors who are not shown personalization. If this is true, all scores will be zeroed,
     * and score updates will be ignored. This has no effect on quirks or tests.
     *
     * If this value is not set, a random roll will be performed to determine membership,
     * based on the control group size.
     */
    controlGroup?: boolean;
};
declare const emptyVisitorData: () => VisitorData;
/**
 * Expresses a 'patch' to the Uniform Context state
 */
declare type ContextState = {
    cookies: Record<string, string>;
    url?: URL;
    quirks: Quirks;
    enrichments: EnrichmentData[];
    events: EventData[];
};
declare type ContextStateUpdate = {
    state: Partial<ContextState>;
    previousState: Partial<ContextState>;
    visitor: VisitorData;
    scores: ScoreVector;
};

declare type TransitionDataStoreOptions = {
    initialData?: Partial<VisitorData>;
};
declare type ServerToClientTransitionState = Pick<Partial<VisitorData>, 'quirks' | 'tests'> & {
    /**
     * Server Score Vector - the resultant scores _on the server side_ after the server/edge render completes
     * Note that the client side does not trust these scores; they are only used until it's done with initial
     * recomputation.
     */
    ssv?: ScoreVector;
};
declare const SERVER_STATE_ID = "__UNIFORM_DATA__";
declare type TransitionDataStoreEvents = {
    /**
     * Fired when the data is updated asynchronously
     * (i.e. a promise resolves with new data from a backend)
     *
     * NOT fired for synchronous updates (e.g. calling updateData()), unless this also results in an async update of the data afterwards.
     * NOT fired if an asynchronous update does not result in any change compared to the last known data.
     */
    dataUpdatedAsync: Partial<VisitorData>;
};
declare abstract class TransitionDataStore {
    #private;
    constructor({ initialData }: TransitionDataStoreOptions);
    get data(): Partial<VisitorData> | undefined;
    /**
     * Subscribe to events from the transition storage
     */
    readonly events: {
        on: {
            <Key extends "dataUpdatedAsync">(type: Key, handler: mitt.Handler<TransitionDataStoreEvents[Key]>): void;
            (type: "*", handler: mitt.WildcardHandler<TransitionDataStoreEvents>): void;
        };
        off: {
            <Key_1 extends "dataUpdatedAsync">(type: Key_1, handler?: mitt.Handler<TransitionDataStoreEvents[Key_1]> | undefined): void;
            (type: "*", handler: mitt.WildcardHandler<TransitionDataStoreEvents>): void;
        };
    };
    /**
     * Updates data in the transition storage.
     * @param commands Commands to execute against existing stored value (event based stores)
     * @param computedValue Pre-computed new value against existing value (object based stores)
     * @returns Resolved promise when the data has been updated
     */
    updateData(commands: StorageCommands[], computedValue: VisitorData): Promise<void>;
    /**
     * Deletes a visitor's stored data, forgetting them.
     * @param fromAllDevices - false: logout from this device ID. true: forget all data about the visitor and their identity.
     */
    delete(fromAllDevices?: boolean): Promise<void>;
    /**
     * Deletes a visitor's stored data, forgetting them.
     * Important: do not emit any async score update events from this function.
     * @param fromAllDevices - false: logout from this device ID. true: forget all data about the visitor and their identity.
     */
    abstract handleDelete(fromAllDevices?: boolean): Promise<void>;
    /**
     * Updates visitor data in the transition store.
     *
     * NOTE: The updated data is optimistically stored in TransitionDataStore automatically,
     * so unless the updated data is _changed_ by the backend data store, there is no need
     * to emit async score changed events when the visitor data is done updating.
     */
    abstract handleUpdateData(commands: StorageCommands[], computedValue: VisitorData): Promise<void>;
    protected signalAsyncDataUpdate(newScores: Partial<VisitorData>): void;
    /**
     * When we load on the client side after a server side rendering has occurred (server to client transition),
     * we can have a page script (ID: __UNIFORM_DATA__) that contains the computed visitor data from the SSR/edge render.
     * This data is injected into the first render to allow score syncing and the server to request commands be applied
     * to the client side data store.
     */
    getClientTransitionState(): ServerToClientTransitionState | undefined;
}

declare type SharedTypes = external['uniform-context-types.swagger.yml']['components']['schemas'];
declare type ManifestV2 = components['schemas']['ManifestV2'];
declare type PersonalizationManifest = components['schemas']['PersonalizationManifest'];
declare type Signal = SharedTypes['Signal'];
declare type SignalCriteriaGroup = SharedTypes['SignalCriteriaGroup'];
declare type SignalCriteria = SharedTypes['SignalCriteria'];
declare type EnrichmentCategory = SharedTypes['EnrichmentCategory'];
declare type StringMatch = SharedTypes['StringMatch'];
declare type NumberMatch = SharedTypes['NumberMatch'];
declare type TestDefinition = SharedTypes['Test'];
declare type AggregateDimension = SharedTypes['AggregateDimension'];
declare type AggregateDimensionInput = SharedTypes['AggregateDimensionInput'];

/**
 * The result of evaluating a signal criteria.
 */
declare type CriteriaEvaluatorResult = {
    /** Whether the criteria evaluated to true or not */
    result: boolean;
    /**
     * Whether the value of the criteria changed from the previous state
     * If ALL criteria on a signal have NOT changed, the signal is skipped
     * and its score is left alone.
     */
    changed: boolean;
};
declare type CriteriaEvaluatorParameters = {
    /** The update being made to the Context state */
    update: ContextStateUpdate;
    /** Current criteria to evaluate the update against */
    criteria: SignalCriteria;
    /**
     * The storage commands that will be executed by this update.
     * If the evaluation requires custom commands, push them into this parameter.
     * NOTE: needing to use this is very rare and should be avoided if possible.
     */
    commands: StorageCommands[];
    /** The parent signal containing the criteria we are evaluating */
    signal: SignalData;
    /** Function to emit log notices to the Context log */
    onLogMessage?: (message: LogMessage) => void;
};
declare type SignalData = Signal & {
    id: string;
};
/**
 * A type that evaluates a signal criteria type and
 * decides if it matches the current Context state or not.
 */
declare type CriteriaEvaluator = ((parameters: CriteriaEvaluatorParameters) => CriteriaEvaluatorResult) & {
    /** If true the criteria will always execute even if a short-circuit would normally skip it */
    alwaysExecute?: boolean;
};

declare class GroupCriteriaEvaluator {
    #private;
    constructor(criteriaEvaluators: Record<string, CriteriaEvaluator>);
    evaluate(update: ContextStateUpdate, crit: SignalCriteriaGroup, commands: StorageCommands[], signal: SignalData, onLogMessage?: (message: LogMessage) => void): CriteriaEvaluatorResult;
}

/** Defines all error codes and their parameter(s)  */
declare type LogMessages = {
    /** Context constructed */
    1: MessageFunc;
    /** Context received data update */
    2: MessageFunc<Partial<Omit<ContextState, 'url'> & {
        url: string;
    }>>;
    /** Context emitted new score vector */
    3: MessageFunc<ScoreVector>;
    /** Context emitted updated quirks */
    4: MessageFunc<Quirks>;
    /** Tried to set enrichment category that did not exist */
    5: MessageFunc<EnrichmentData>;
    /** Storage received update commands */
    101: MessageFunc<StorageCommands[]>;
    /** Storage data was updated */
    102: MessageFunc<VisitorData>;
    /** Storage data was deleted bool: fromAllDevices */
    103: MessageFunc<boolean>;
    /** Visitor was assigned or removed from control group */
    104: MessageFunc<boolean>;
    /** Storage score was truncated to its cap */
    110: MessageFunc<{
        dim: string;
        score: number;
        cap: number;
    }>;
    /** Storage visitor data expired and was cleared */
    120: MessageFunc;
    /** Server to client transition score data was loaded */
    130: MessageFunc<ScoreVector>;
    /** Server to client transition data was discarded */
    131: MessageFunc;
    /** Decay function executed */
    140: MessageFunc<string>;
    /** Signals evaluation beginning */
    200: MessageFunc;
    /** Evaluation of a specific signal beginning */
    201: MessageFunc<SignalData>;
    /** Evaluation of a group beginning */
    202: MessageFunc<SignalCriteriaGroup>;
    203: MessageFunc<{
        criteria: SignalCriteria;
        result: CriteriaEvaluatorResult;
        explanation: string;
    }>;
    /** Result of evaluating a criteria group */
    204: MessageFunc<CriteriaEvaluatorResult>;
    /** Personalization placement executing */
    300: MessageFunc<{
        name: string;
        take?: number;
    }>;
    /** Personalization placement testing variation */
    301: MessageFunc<{
        id: string;
        op?: string;
    }>;
    /** Processed a personalization criteria */
    302: MessageFunc<{
        matched: boolean;
        description: string;
    }>;
    /** Final result for a personalized variation */
    303: MessageFunc<boolean>;
    /** A/B test placement executing */
    400: MessageFunc<string>;
    /** A/B Test definition did not exist */
    401: MessageFunc<string>;
    /** Previously shown test variant no longer in variant data */
    402: MessageFunc<{
        missingVariant: string;
        variants: string[];
    }>;
    /** Selected a new A/B test variation */
    403: MessageFunc<string>;
    /** Displaying A/B test variation */
    404: MessageFunc<string>;
    /** gtag was not present on the page to emit events to */
    700: MessageFunc;
    /** Enabled gtag event signal redirection */
    701: MessageFunc;
};

declare type Severity = 'debug' | 'info' | 'warn' | 'error';
declare type MessageCategory = 'context' | 'storage' | 'testing' | 'personalization' | 'gtag' | 'signals';
declare type OutputSeverity = Severity | 'none';
declare type MessageFunc<TArg = void> = (arg: TArg) => [
    /** Category of the message */
    MessageCategory,
    /** Log message text */
    string,
    /** Log message */
    ...unknown[]
];
declare type LogMessage = LogMessageSingle | LogMessageGroup;
declare type LogMessageSingle<TID extends keyof LogMessages = keyof LogMessages> = [
    severity: Severity,
    id: TID,
    ...args: Parameters<LogMessages[TID]>
];
declare type LogMessageGroup<TID extends keyof LogMessages = keyof LogMessages> = [severity: Severity, id: TID, group: 'GROUP', ...args: Parameters<LogMessages[TID]>] | [severity: Severity, id: TID, group: 'ENDGROUP'];
declare type LogDrain = (message: LogMessage) => void;

declare type DecayOptions = {
    now: number;
    lastUpd: number | undefined;
    scores: ScoreVector;
    sessionScores: ScoreVector;
    onLogMessage?: (message: LogMessage) => void;
};
/**
 * Computes decay of visitor scores over time.
 * NOTE: it is expected that this function mutates the incoming score vectors,
 * if it needs to apply score decay. The data store ensures immutability already.
 *
 * @returns true if any decay was applied, false otherwise
 */
declare type DecayFunction = (options: DecayOptions) => boolean;

declare type VisitorDataStoreOptions = {
    /** Transition storage used to transfer server or edge side execution state to the client. Unused for client side only. */
    transitionStore?: TransitionDataStore;
    /** Duration of a 'visit' measured by this number of milliseconds without performing any updates */
    visitLifespan?: number;
    /** Personalization manifest data. If set, the data store will automatically apply score caps in the manifest data. */
    manifest?: ManifestInstance;
    /** Allows decaying of scores over time based on time between visits. Default: no decay */
    decay?: DecayFunction;
    /**
     * Sets the default value of storage consent for new unknown visitors.
     * If storage consent is not given, only in-memory data will be stored which is lost when the browser leaves the page.
     * @default false - consent is not given for new visitors until they explicitly give it with an update command
     */
    defaultConsent?: boolean;
    /**
     * Function called when server-to-client transfer state is loaded and contains server-side computed scores.
     * These scores are used as a temporary shim for the current scores on the client side, until score computation
     * is completed the first time (which occurs when the current url is fed into the Context).
     *
     * Because the feed of the URL may be marginally delayed (for example in React it's in an effect so it's a second render),
     * one render might be done with _no_ scores unless we dropped the server scores in temporarily, resulting in a flash of unpersonalized content.
     */
    onServerTransitionReceived?: (state: ServerToClientTransitionState) => void;
    /** Called when a log message is emitted from the data store */
    onLogMessage?: (message: LogMessage) => void;
};
declare type VisitorDataStoreEvents = {
    /**
     * Fired when the stored data is updated.
     * This is fired for any update, whether from integrated or transition storage.
     * The event is NOT fired if an update does not result in any score changes.
     */
    scoresUpdated: Pick<VisitorData, 'scores' | 'sessionScores'>;
    /**
     * Fired when stored quirks are updated.
     * This is fired for any update, whether from integrated or transition storage.
     * The event is NOT fired if an update does not result in any quirk changes.
     */
    quirksUpdated: Pick<VisitorData, 'quirks'>;
    /**
     * Fired when test variant selection is updated.
     */
    testsUpdated: Pick<VisitorData, 'tests'>;
    /**
     * Fired when storage consent is changed
     */
    consentUpdated: Pick<VisitorData, 'consent'>;
    /**
     * Fired when visitor control group membership is changed
     */
    controlGroupUpdated: Pick<VisitorData, 'controlGroup'>;
};
declare class VisitorDataStore {
    #private;
    constructor(options: VisitorDataStoreOptions);
    /** Gets the current visitor data. This property is always up to date. */
    get data(): VisitorData;
    get decayEnabled(): boolean;
    /**
     * Subscribe to events from storage
     */
    readonly events: {
        on: {
            <Key extends keyof VisitorDataStoreEvents>(type: Key, handler: mitt.Handler<VisitorDataStoreEvents[Key]>): void;
            (type: "*", handler: mitt.WildcardHandler<VisitorDataStoreEvents>): void;
        };
        off: {
            <Key_1 extends keyof VisitorDataStoreEvents>(type: Key_1, handler?: mitt.Handler<VisitorDataStoreEvents[Key_1]> | undefined): void;
            (type: "*", handler: mitt.WildcardHandler<VisitorDataStoreEvents>): void;
        };
    };
    /** Push data update command(s) into the visitor data */
    updateData(commands: StorageCommands[]): Promise<void>;
    /**
     * Deletes visitor data (forgetting them)
     * In most cases you should use forget() on the Context instead of this function, which also clears the Context state.
     * @param fromAllDevices for an identified user, whether to delete all their data (for the entire account) - true, or data for this device (sign out) - false
     */
    delete(fromAllDevices: boolean): Promise<void>;
}

declare class ManifestInstance {
    #private;
    readonly data: ManifestV2;
    constructor({ manifest, evaluator, onLogMessage, }: {
        manifest: ManifestV2;
        evaluator?: GroupCriteriaEvaluator;
        onLogMessage?: (message: LogMessage) => void;
    });
    rollForControlGroup(): boolean;
    getTest(name: string): TestDefinition | undefined;
    computeSignals(update: ContextStateUpdate): StorageCommands[];
    /**
     * Computes aggregated scores based on other dimensions
     */
    computeAggregateDimensions(primitiveScores: ScoreVector): ScoreVector;
    getDimensionByKey(scoreKey: string): EnrichmentCategory | Signal | undefined;
}

/** Content that is tagged for adding enrichment score when triggered by behavior (i.e. being shown that content) */
declare type BehaviorTag = {
    beh?: EnrichmentData[];
};
/** Defines the shape of a personalized content variant */
declare type PersonalizedVariant = {
    /** A unique identifier for this variation */
    id: string;
    /** Match criteria for this variation */
    pz?: VariantMatchCriteria;
};
/** The result of computing personalized content from variations */
declare type PersonalizedResult<TVariant> = {
    /** Whether or not this result contains a personalized result */
    personalized: boolean;
    /** Matching variations */
    variations: Array<TVariant>;
};
/** Defines the shape of a A/B test variant */
declare type TestVariant = {
    /** The identifier for this variant. This value persisted to storage when a variant is selected. */
    id: string;
    /**
     * A number between 0 and 100 representing what percentage of visitors will be selected for this variant.
     * If not provided, this variant will be selected in equal proportion to other variants without an explicit distribution.
     */
    testDistribution?: number;
};
/** The result of computing an A/B test result */
declare type TestResult<TVariant> = {
    /** The selected variation */
    result: TVariant | undefined;
    /**
     * Whether the test variant was newly assigned to the visitor.
     * True: variant was assigned to the visitor for the first time.
     * False: variant was already assigned to the visitor and is being reused.
     */
    variantAssigned: boolean;
};

declare type PersonalizeOptions<TVariant> = {
    /** Name of placement (sent to analytics) */
    name: string;
    /** Possible variants to place  */
    variations: Iterable<TVariant>;
    /** Maximum number of variants to place (default: 1) */
    take?: number;
    onLogMessage?: (message: LogMessage) => void;
};
declare function personalizeVariations<TVariant extends PersonalizedVariant>({ name, context, variations, take, onLogMessage, }: PersonalizeOptions<TVariant> & {
    context: Context;
}): PersonalizedResult<TVariant>;

declare type VariantMatchCriteria = {
    /**
     * Operation for match criteria
     *
     * @defaultValue `&`
     */
    op?: '&' | '|';
    crit: DimensionMatch[];
};
declare type DimensionMatch = {
    /**
     * Left hand side of the match expression (name of dimension in score vector)
     * NOTE: if the dimension is not present in the score vector, it will be treated as if it has a value of 0
     */
    l: string;
    /**
     * Operator of the match expression
     * Whole-vector (RHS only) operators - these do not require a `r` or `rDim` set:
     * +: `l` is the strongest dimension in the score vector
     * -: `l` is the weakest dimension in the score vector. This does not match if the dimension has no score at all.
     *
     * Comparison operators:
     * >: `l` is greater than the right hand side expression
     * >= : `l` is greater than or equal to the right hand side expression
     * <: `l` is less than the right hand side expression
     * <= : `l` is less than or equal to the right hand side expression
     * =: `l` is equal to the right hand side expression
     * !=: `l` is not equal to the right hand side expression
     */
    op: '+' | '-' | '>' | '>=' | '<' | '<=' | '=' | '!=';
    /**
     * Right hand side of the match expression (not required for op = + or - which have no right side)
     * This value is treated as a constant value, if it is present. If it's a string, it is parsed to an integer.
     * To reference another score dimension as the RHS, use the `rDim` property instead.
     * `r` and `rDim` are mutually exclusive; if both are specified, then `rDim` wins.
     */
    r?: number | string;
    /**
     * Right hand side of the match expression (not required for op = + or - which have no right side)
     * This value is treated as a reference to another score dimension, if it is present in the score vector.
     * If the referenced dimension is NOT present in the score vector, the match will always be false.
     * To reference a constant value instead as the RHS, use the `r` property instead.
     * `r` and `rDim` are mutually exclusive; if both are specified, then `rDim` wins.
     */
    rDim?: string;
};

declare type TestOptions<TVariant extends TestVariant> = {
    /** The name of the test that is being run, must be included in the manifest. */
    name: string;
    /** Variations that are being tested. */
    variations: TVariant[];
};
declare const testVariations: <TVariant extends TestVariant>({ name, context, variations, onLogMessage, }: TestOptions<TVariant> & {
    context: Context;
    onLogMessage?: ((message: LogMessage) => void) | undefined;
}) => TestResult<TVariant>;

/**
 * Defines a plugin for Uniform Context.
 * The plugin should attach event handlers in its creation function.
 * @returns A function that detaches any event handlers when called
 */
declare type ContextPlugin = {
    logDrain?: LogDrain;
    init?: (context: Context) => () => void;
};
declare type ContextOptions = {
    /** The Context Manifest to load (from the Context API) */
    manifest: ManifestV2;
    /**
     * Context plugins to load at initialize time.
     * Plugins that hook to the log event should be added here so that they can catch init-time log message events.
     *
     * Note that the Context passed to the plugin is not yet fully initialized, and is intended for event handler attachment
     * only - don't call scores, update, etc on it. If you need to call these methods immediately, attach your plugin after initialisation.
     */
    plugins?: Array<ContextPlugin>;
} & Omit<VisitorDataStoreOptions, 'manifest' | 'onServerTransitionScoresReceived'>;
/** Emitted when a personalization runs */
declare type PersonalizationEvent = {
    /** Name of the personalized placement */
    name: string;
    /** Selected variant ID(s) */
    variantIds: string[];
    /** Whether the user was part of the control group (and did not receive any personalization) */
    control: boolean | undefined;
    /**
     * Whether the personalized placement has changed since the last time the placement was evaluated.
     * True: the placement was evaluated for the first time, or the variant(s) selected changed from last time (e.g. due to a score change that activated a new variant).
     * False: the variant(s) selected were the same as a previous evaluation of this placement.
     */
    changed: boolean;
};
/** Emitted event when an A/B test runs */
declare type TestEvent = {
    /** Name (public ID) of the A/B test */
    name: string;
    /** ID of the variant that was selected */
    variantId: string | undefined;
    /**
     * Whether the test variant was newly assigned to the visitor.
     * True: variant was assigned to the visitor for the first time.
     * False: variant was already assigned to the visitor and is being reused.
     */
    variantAssigned: boolean;
};
declare type ContextEvents = {
    /**
     * Fired when the scores are updated.
     * The event is NOT fired if an update does not result in any score changes.
     * The result is merged between session and permanent data.
     */
    scoresUpdated: Readonly<ScoreVector>;
    /**
     * Fired when quirk data changes. Not fired if no changes to quirks are made
     * (e.g. setting it to the same value it already has)
     */
    quirksUpdated: Quirks;
    /**
     * Fired when a log message is emitted from Context
     * Note that event handlers attached to this event will not catch events
     * logged during initialisation of the Context unless they are attached as plugins to the constructor.
     */
    log: LogMessage | LogMessageGroup;
    /** Test variant has been selected */
    testResult: TestEvent;
    /** Personalization variants have been selected */
    personalizationResult: PersonalizationEvent;
};
declare class Context implements Context {
    #private;
    readonly manifest: ManifestInstance;
    constructor(options: ContextOptions);
    /** Gets the current visitor's dimension score vector. */
    get scores(): Readonly<ScoreVector>;
    /** Gets the current visitor's quirks values. */
    get quirks(): Readonly<Quirks>;
    /**
     * Subscribe to events
     */
    readonly events: {
        on: {
            <Key extends keyof ContextEvents>(type: Key, handler: mitt.Handler<ContextEvents[Key]>): void;
            (type: "*", handler: mitt.WildcardHandler<ContextEvents>): void;
        };
        off: {
            <Key_1 extends keyof ContextEvents>(type: Key_1, handler?: mitt.Handler<ContextEvents[Key_1]> | undefined): void;
            (type: "*", handler: mitt.WildcardHandler<ContextEvents>): void;
        };
    };
    readonly storage: VisitorDataStore;
    /**
     * Updates the Context with new data of any sort, such as
     * new URLs, cookies, quirks, and enrichments.
     *
     * Only properties that are set in the data parameter will be updated.
     * Properties that do not result in a changed state,
     * i.e. pushing the same URL or cookies as before,
     * will NOT result in a recomputation of signal state.
     */
    update(newData: Partial<ContextState>): Promise<void>;
    /** use test() instead */
    getTestVariantId(testName: string): string | null | undefined;
    /** use test() instead */
    setTestVariantId(testName: string, variantId: string): void;
    /**
     * Writes a message to the Context log sink.
     * Used by Uniform internal SDK; not intended for public use.
     */
    log(...message: LogMessage): void;
    /** Executes an A/B test with a given set of variants, showing the visitor's assigned variant (or selecting one to assign, if none is set yet) */
    test<TVariant extends TestVariant>(options: TestOptions<TVariant>): TestResult<TVariant>;
    /** Executes a personalized placement with a given set of variants */
    personalize<TVariant extends PersonalizedVariant>(options: PersonalizeOptions<TVariant>): PersonalizedResult<TVariant>;
    /**
     * Forgets the visitor's data and resets the Context to its initial state.
     * @param fromAllDevices for an identified user, whether to delete all their data (for the entire account) - true, or data for this device (sign out) - false
     */
    forget(fromAllDevices: boolean): Promise<void>;
}

/**
 * The version of the DevTools UI to load when in Chromium extension context.
 * 1: Uniform Optimize.
 * 2: Uniform Context.
 */
declare type DevToolsUiVersion = 1 | 2;
/**
 * The data state provided to the devtools for rendering.
 */
declare type DevToolsState = {
    /** Current computed visitor scores (includes aggregates) */
    scores: Readonly<ScoreVector>;
    /** Current visitor data (includes quirks, raw scores, tests, consent, etc) */
    data: Readonly<VisitorData>;
    /** Personalization events that have fired since devtools started */
    personalizations: Array<PersonalizationEvent>;
    /** Test events that have fired since devtools started */
    tests: Array<TestEvent>;
    /** The Context manifest */
    manifest: ManifestV2;
};
/** Mutations the DevTools can take on the data it receives */
declare type DevToolsActions = {
    /** Standard updates; maps to Context.update() */
    update: (newData: Partial<ContextState>) => Promise<void>;
    /** Raw updates to the storage subsystem. Maps to Context.storage.updateData() */
    rawUpdate: (commands: StorageCommands[]) => Promise<void>;
    /** Forget the current visitor and clear data on this device */
    forget: () => Promise<void>;
};
declare type DevToolsEvent<Type extends string = string, TEventData = unknown> = {
    /** The integration ID that is required */
    type: Type;
} & TEventData;
declare type DevToolsEvents = DevToolsLogEvent | DevToolsDataEvent | DevToolsHelloEvent | DevToolsUpdateEvent | DevToolsRawCommandsEvent | DevToolsForgetEvent;
/** A log message emitted as an event to the browser extension */
declare type DevToolsLogEvent = DevToolsEvent<'uniform:context:log', {
    message: LogMessage;
}>;
/** Emitted when data is updated in Context to the devtools */
declare type DevToolsDataEvent = DevToolsEvent<'uniform:context:data', {
    data: DevToolsState;
}>;
/** A hello message emitted as an event from the browser extension to test if the page contains Context */
declare type DevToolsHelloEvent = DevToolsEvent<'uniform:context:hello', {
    uiVersion: DevToolsUiVersion;
}>;
/** Devtools requests a normal update cycle (regular data update, re-eval signals, etc) */
declare type DevToolsUpdateEvent = DevToolsEvent<'uniform-in:context:update', {
    newData: Partial<ContextState>;
}>;
/** Devtools requests a raw update cycle (explicitly set scores of dimensions in durations, etc) */
declare type DevToolsRawCommandsEvent = DevToolsEvent<'uniform-in:context:commands', {
    commands: StorageCommands[];
}>;
/** A request to forget me from the DevTools */
declare type DevToolsForgetEvent = DevToolsEvent<'uniform-in:context:forget', unknown>;
declare global {
    interface Window {
        /** Window var set by enableContextDevTools() to enable embedded devtools to receive Context instance and attach events to it. */
        __UNIFORM_DEVTOOLS_CONTEXT_INSTANCE__?: Context;
    }
}

export { ContextEvents as $, AggregateDimension as A, SetTestCommand as B, ContextPlugin as C, DecayFunction as D, EnrichmentCategory as E, SetControlGroupCommand as F, GroupCriteriaEvaluator as G, DecayOptions as H, IdentifyCommand as I, VisitorDataStoreOptions as J, VisitorDataStoreEvents as K, LogDrain as L, ManifestInstance as M, NumberMatch as N, OutputSeverity as O, PersonalizationManifest as P, Quirks as Q, VisitorDataStore as R, StorageCommands as S, TransitionDataStore as T, ServerToClientTransitionState as U, VisitorData as V, SERVER_STATE_ID as W, TransitionDataStoreEvents as X, ContextOptions as Y, PersonalizationEvent as Z, TestEvent as _, TransitionDataStoreOptions as a, Context as a0, LogMessages as a1, Severity as a2, MessageCategory as a3, MessageFunc as a4, LogMessageSingle as a5, LogMessageGroup as a6, testVariations as a7, TestOptions as a8, PersonalizeOptions as a9, personalizeVariations as aa, DimensionMatch as ab, BehaviorTag as ac, PersonalizedVariant as ad, PersonalizedResult as ae, TestVariant as af, TestResult as ag, DevToolsUiVersion as ah, DevToolsState as ai, DevToolsActions as aj, DevToolsEvent as ak, DevToolsEvents as al, DevToolsLogEvent as am, DevToolsDataEvent as an, DevToolsHelloEvent as ao, DevToolsUpdateEvent as ap, DevToolsRawCommandsEvent as aq, DevToolsForgetEvent as ar, CriteriaEvaluator as b, StringMatch as c, ScoreVector as d, VariantMatchCriteria as e, LogMessage as f, ManifestV2 as g, Signal as h, SignalCriteriaGroup as i, SignalCriteria as j, TestDefinition as k, AggregateDimensionInput as l, CriteriaEvaluatorResult as m, CriteriaEvaluatorParameters as n, SignalData as o, Tests as p, EnrichmentData as q, EventData as r, emptyVisitorData as s, ContextState as t, ContextStateUpdate as u, StorageCommand as v, ModifyScoreCommand as w, ModifySessionScoreCommand as x, SetConsentCommand as y, SetQuirkCommand as z };
