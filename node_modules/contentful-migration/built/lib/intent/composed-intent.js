"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
function mergeSections(sections) {
    const sameSections = lodash_1.groupBy(sections, 'heading');
    const mergedSections = [];
    for (const [heading, sections] of lodash_1.entries(sameSections)) {
        const details = lodash_1.flatten(sections.map((section) => section.details || []));
        const section = { heading, details };
        mergedSections.push(section);
    }
    if (mergedSections.length > 1) {
        throw new Error('mergeSections expect to receive sections from same type (i.e. same heading)');
    }
    return mergedSections[0];
}
class ComposedIntent {
    constructor(intents) {
        // Intents share the same content type id
        this.contentTypeId = intents[0].getContentTypeId();
        this.tagId = intents[0].getTagId();
        this.intents = intents;
    }
    getIntents() {
        return this.intents;
    }
    // TODO: adjust interface so we don't have to implement all this
    getFieldId() {
        return null;
    }
    getRawType() {
        return null;
    }
    isEditorInterfaceUpdate() {
        return false;
    }
    isContentTypeUpdate() {
        return false;
    }
    isContentTypeDelete() {
        return false;
    }
    isContentTypeCreate() {
        return false;
    }
    isFieldCreate() {
        return false;
    }
    isFieldUpdate() {
        return false;
    }
    isFieldDelete() {
        return false;
    }
    isFieldRename() {
        return false;
    }
    isFieldMove() {
        return false;
    }
    isAboutContentType() {
        return false;
    }
    isAboutField() {
        return false;
    }
    isContentTransform() {
        return false;
    }
    isEntryDerive() {
        return false;
    }
    isEntryTransformToType() {
        return false;
    }
    isGroupable() {
        return false;
    }
    isEditorInterfaceIntent() {
        return false;
    }
    isSidebarUpdate() {
        return true;
    }
    getContentTypeId() {
        return this.contentTypeId;
    }
    getRelatedContentTypeIds() {
        return [this.getContentTypeId()];
    }
    requiresAllEntries() {
        return false;
    }
    requiresAllTags() {
        return this.intents.some(intent => intent.requiresAllTags());
    }
    groupsWith() {
        return false;
    }
    endsGroup() {
        return false;
    }
    toRaw() {
        throw new Error('Not implemented');
    }
    shouldSave() {
        return this.intents.some(intent => intent.shouldSave());
    }
    shouldPublish() {
        return this.intents.some(intent => intent.shouldPublish());
    }
    isComposedIntent() {
        return true;
    }
    isTagIntent() {
        // TODO Is this a viable option? How can we be sure that composed
        // intents are not a mix of ct intents and tag intents?
        return this.intents.some(intent => intent.isTagIntent());
    }
    getTagId() {
        return this.tagId;
    }
    isTagCreate() {
        return false;
    }
    isTagUpdate() {
        return false;
    }
    isTagDelete() {
        return false;
    }
    isEntrySetTags() {
        return false;
    }
    toActions() {
        return lodash_1.flatten(this.intents.map((intent) => intent.toActions()));
    }
    toPlanMessage() {
        const [firstIntent] = this.intents;
        // TODO: show more details about entry transforms
        if (firstIntent.isContentTransform()) {
            const singleHeading = firstIntent.toPlanMessage().heading;
            const transformCount = this.intents.length;
            const combinedHeading = `${singleHeading} (${transformCount}x)`;
            return {
                heading: combinedHeading,
                sections: [],
                details: []
            };
        }
        const mainHeading = firstIntent.toPlanMessage().heading;
        const contentTypeOrTagUpdates = this.intents.filter((intent) => intent.isContentTypeUpdate() || intent.isTagUpdate());
        const fieldCreates = this.intents.filter((intent) => intent.isFieldCreate());
        const editorInterfaceUpdates = this.intents.filter((intent) => intent.isEditorInterfaceUpdate());
        const createdFieldIds = fieldCreates.map((createIntent) => createIntent.getFieldId());
        const fieldUpdates = this.intents.filter((intent) => intent.isFieldUpdate());
        const fieldMoves = this.intents.filter((intent) => intent.isFieldMove());
        const createdFieldUpdates = fieldUpdates.filter((updateIntent) => createdFieldIds.includes(updateIntent.getFieldId()));
        const onlyFieldUpdates = lodash_1.difference(fieldUpdates, createdFieldUpdates);
        const onlyFieldUpdatesByField = lodash_1.groupBy(onlyFieldUpdates, (intent) => intent.getFieldId());
        const createdFieldUpdatesByField = lodash_1.groupBy(createdFieldUpdates, (intent) => intent.getFieldId());
        const topLevelDetails = lodash_1.flatten(contentTypeOrTagUpdates.map((updateIntent) => updateIntent.toPlanMessage().details));
        const sidebarUpdates = lodash_1.flatten(this.intents
            .filter((intent) => intent.isSidebarUpdate())
            .map(i => i.toPlanMessage().sections));
        let createSections = [];
        for (const editorInterfaceIntent of editorInterfaceUpdates) {
            const updateSections = editorInterfaceIntent.toPlanMessage().sections;
            const [updateSection] = updateSections;
            const heading = updateSection.heading;
            const mergedSection = mergeSections(updateSections) || { details: [] };
            const nextUpdateSection = Object.assign(Object.assign({}, mergedSection), { heading });
            createSections.push(nextUpdateSection);
        }
        for (const createIntent of fieldCreates) {
            const fieldId = createIntent.getFieldId();
            const [createSection] = createIntent.toPlanMessage().sections;
            const heading = createSection.heading;
            const updateIntents = createdFieldUpdatesByField[fieldId] || [];
            const allFieldUpdateSections = lodash_1.flatten(updateIntents.map((fieldIntent) => fieldIntent.toPlanMessage().sections));
            const mergedSection = mergeSections(allFieldUpdateSections) || { details: [] };
            const nextCreateSection = Object.assign(Object.assign({}, mergedSection), { heading });
            createSections.push(nextCreateSection);
        }
        for (const updateIntents of lodash_1.values(onlyFieldUpdatesByField)) {
            const allSections = lodash_1.flatten(updateIntents.map((intent) => intent.toPlanMessage().sections));
            const nextUpdateSection = mergeSections(allSections);
            createSections.push(nextUpdateSection);
        }
        for (const moveIntent of fieldMoves) {
            const planMessage = moveIntent.toPlanMessage();
            createSections = createSections.concat(planMessage.sections);
        }
        createSections = [...createSections, ...sidebarUpdates];
        return {
            heading: mainHeading,
            details: topLevelDetails,
            sections: createSections
        };
    }
}
exports.default = ComposedIntent;
//# sourceMappingURL=composed-intent.js.map