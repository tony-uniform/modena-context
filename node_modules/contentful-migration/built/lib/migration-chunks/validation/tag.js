"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const errors_1 = __importDefault(require("./errors"));
const tagErrors = errors_1.default.tag;
const checkTagId = (tagId, context) => {
    const exists = context.remote.has(tagId) || context.created.has(tagId);
    const willBeCreated = context.toBeCreated.has(tagId);
    const deleted = context.deleted.has(tagId);
    return { tagId, exists, willBeCreated, deleted };
};
class DuplicateCreate {
    validate(intent, context) {
        if (!intent.isTagCreate()) {
            return;
        }
        const tagId = intent.getTagId();
        if (!context.created.has(tagId)) {
            return;
        }
        return tagErrors.create.TAG_ALREADY_CREATED(tagId);
    }
}
class EditBeforeCreates {
    validate(intent, context) {
        const isRelevant = intent.isTagUpdate();
        if (!isRelevant) {
            return;
        }
        const tagId = intent.getTagId();
        const { exists, willBeCreated } = checkTagId(tagId, context);
        if (exists || !willBeCreated) {
            return;
        }
        if (intent.isTagUpdate()) {
            return tagErrors.update.TAG_NOT_YET_CREATED(tagId);
        }
    }
}
class NonExistingEdits {
    validate(intent, context) {
        const isRelevant = intent.isTagUpdate();
        if (!isRelevant) {
            return;
        }
        const tagId = intent.getTagId();
        const { exists, willBeCreated } = checkTagId(tagId, context);
        if (exists || willBeCreated) {
            return;
        }
        if (intent.isTagUpdate()) {
            return tagErrors.update.TAG_DOES_NOT_EXIST(tagId);
        }
        if (intent.isContentTransform()) {
            return tagErrors.transformEntries.TAG_DOES_NOT_EXIST(tagId);
        }
    }
}
class AlreadyExistingIdCreates {
    constructor() {
        this.message = tagErrors.create.TAG_ALREADY_EXISTS;
    }
    validate(intent, context) {
        if (!intent.isTagCreate()) {
            return;
        }
        const tagId = intent.getTagId();
        if (!context.remote.has(tagId)) {
            return;
        }
        return tagErrors.create.TAG_ALREADY_EXISTS(tagId);
    }
}
class AlreadyExistingNameUpdates {
    constructor() {
        this.message = tagErrors.update.TAG_NAME_ALREADY_EXISTS;
    }
    validate(intent, context) {
        if (!intent.isTagUpdate()) {
            return;
        }
        const tagName = intent.toRaw().payload.props.name;
        if (!context.remoteTags.find(tag => tag.name === tagName)) {
            return;
        }
        return tagErrors.update.TAG_NAME_ALREADY_EXISTS(tagName);
    }
}
class NonExistingDeletes {
    validate(intent, context) {
        if (!intent.isTagDelete()) {
            return;
        }
        const tagId = intent.getTagId();
        if (context.remote.has(tagId) || context.deleted.has(tagId)) {
            return;
        }
        return tagErrors.delete.TAG_DOES_NOT_EXIST(tagId);
    }
}
class DuplicateDeletes {
    validate(intent, context) {
        if (!intent.isTagDelete()) {
            return;
        }
        const tagId = intent.getTagId();
        if (!context.deleted.has(tagId)) {
            return;
        }
        return tagErrors.delete.TAG_ALREADY_DELETED(tagId);
    }
}
class EditsAfterDeletes {
    validate(intent, context) {
        const isRelevant = intent.isTagUpdate();
        if (!isRelevant) {
            return;
        }
        const tagId = intent.getTagId();
        const { deleted } = checkTagId(tagId, context);
        if (!deleted) {
            return;
        }
        if (intent.isTagUpdate()) {
            return tagErrors.delete.EDIT_AFTER_DELETE(tagId);
        }
    }
}
const checks = [
    new DuplicateCreate(),
    new EditBeforeCreates(),
    new EditsAfterDeletes(),
    new NonExistingEdits(),
    new NonExistingDeletes(),
    new AlreadyExistingIdCreates(),
    new AlreadyExistingNameUpdates(),
    new DuplicateDeletes()
];
function default_1(intents, tags) {
    const remote = tags.map((tag) => tag.id);
    const toBeCreated = intents.filter((intent) => intent.isTagCreate()).map((intent) => intent.getTagId());
    let context = {
        remote: new Set(remote),
        created: new Set(),
        deleted: new Set(),
        toBeCreated: new Set(toBeCreated),
        remoteTags: tags
    };
    let errors = [];
    for (const intent of intents) {
        let error;
        for (const check of checks) {
            error = check.validate(intent, context);
            if (error && error.length) {
                // proceed with next intent
                break;
            }
        }
        if (error) {
            const errorList = Array.isArray(error) ? error : [error];
            const invalidActions = errorList.map((error) => ({
                type: 'InvalidAction',
                message: error,
                details: { intent }
            }));
            errors = errors.concat(invalidActions);
            // do not update context
            continue;
        }
        const tagId = intent.getTagId();
        if (intent.isTagCreate()) {
            context.created.add(tagId);
            context.toBeCreated.delete(tagId);
            context.deleted.delete(tagId);
        }
        if (intent.isTagDelete()) {
            context.deleted.add(tagId);
            context.remote.delete(tagId);
            context.created.delete(tagId);
        }
    }
    return errors;
}
exports.default = default_1;
//# sourceMappingURL=tag.js.map