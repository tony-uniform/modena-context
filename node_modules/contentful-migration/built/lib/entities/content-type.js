"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EditorInterfaces = exports.Fields = exports.ContentType = exports.default = void 0;
const lodash_1 = require("lodash");
const sidebarwidget_1 = require("../action/sidebarwidget");
class Fields {
    constructor(fields = []) {
        this._fields = fields;
    }
    getField(id) {
        return lodash_1.find(this._fields, { id });
    }
    setField(id, field) {
        const allFields = this.fields;
        const currentFieldIndex = allFields.findIndex((field) => field.id === id);
        if (currentFieldIndex === -1) {
            allFields.push(field);
        }
        else {
            allFields[currentFieldIndex] = field;
        }
        this._fields = allFields;
    }
    deleteField(id) {
        const fieldToDelete = lodash_1.find(this._fields, { id });
        lodash_1.pull(this._fields, fieldToDelete);
    }
    moveField(id, direction, pivot) {
        const fields = this._fields;
        const field = this.getField(id);
        lodash_1.pull(fields, field);
        if (direction === 'toTheTop') {
            fields.unshift(field);
        }
        if (direction === 'toTheBottom') {
            fields.push(field);
        }
        const pivotIndex = lodash_1.findIndex(fields, { id: pivot });
        if (direction === 'afterField') {
            fields.splice(pivotIndex + 1, 0, field);
        }
        if (direction === 'beforeField') {
            fields.splice(pivotIndex, 0, field);
        }
    }
    filter(predicate) {
        return lodash_1.filter(this._fields, predicate);
    }
    map(mapper) {
        return this._fields.map(mapper);
    }
    get fields() {
        return this._fields;
    }
    set fields(fields) {
        this._fields = fields;
    }
    clone() {
        return new Fields(this.toRaw());
    }
    toRaw() {
        return lodash_1.cloneDeep(this.fields);
    }
}
exports.Fields = Fields;
class EditorInterfaces {
    constructor(apiEditorInterfaces) {
        this._version = apiEditorInterfaces.sys.version;
        this._controls = apiEditorInterfaces.controls;
        this._sidebar = apiEditorInterfaces.sidebar || undefined;
        this._editor = apiEditorInterfaces.editor || undefined;
        this._editors = apiEditorInterfaces.editors || undefined;
    }
    get version() {
        return this._version;
    }
    set version(version) {
        this._version = version;
    }
    getSidebar() {
        return this._sidebar;
    }
    getEditor() {
        return this._editor;
    }
    getEditors() {
        return this._editors;
    }
    getControls() {
        return this._controls;
    }
    reset(fieldId) {
        let controlIndex = lodash_1.findIndex(this._controls, (c) => {
            return c.fieldId === fieldId;
        });
        if (controlIndex !== -1) {
            this._controls.splice(controlIndex, 1);
        }
    }
    copy(fromFieldId, toFieldId) {
        let control = lodash_1.find(this._controls, (c) => {
            return c.fieldId === fromFieldId;
        });
        if (control) {
            this.update(toFieldId, control.widgetId, control.settings, control.widgetNamespace);
        }
    }
    update(fieldId, widgetId, settings, widgetNamespace) {
        let control = lodash_1.find(this._controls, (c) => {
            return c.fieldId === fieldId;
        });
        if (!control) {
            control = {
                fieldId: fieldId,
                widgetId: widgetId
            };
            control.fieldId = fieldId;
            this._controls.push(control);
        }
        control.widgetId = widgetId;
        if (settings) {
            lodash_1.forEach(settings, (v, k) => {
                control.settings = control.settings || {};
                control.settings[k] = v;
            });
        }
        if (widgetNamespace) {
            control.widgetNamespace = widgetNamespace;
        }
    }
    addSidebarWidget(widgetId, widgetNamespace, settings, insertBeforeWidgetId, disabled) {
        this._sidebar = Array.isArray(this._sidebar) ? this._sidebar : [].concat(sidebarwidget_1.DEFAULT_SIDEBAR_LIST);
        const isDuplicateWidget = this._sidebar.find(widget => widget.widgetId === widgetId && widget.widgetNamespace === widgetNamespace);
        if (isDuplicateWidget) {
            return;
        }
        const nextWidgetIndex = this._sidebar.map(w => w.widgetId).indexOf(insertBeforeWidgetId);
        const newWidget = {
            disabled,
            settings,
            widgetId,
            widgetNamespace
        };
        if (nextWidgetIndex < 0) {
            this._sidebar.push(newWidget);
        }
        else {
            this._sidebar.splice(nextWidgetIndex, 0, newWidget);
        }
    }
    updateSidebarWidget(widgetId, widgetNamespace, settings, disabled) {
        this._sidebar = Array.isArray(this._sidebar) ? this._sidebar : [].concat(sidebarwidget_1.DEFAULT_SIDEBAR_LIST);
        const existingWidget = this._sidebar.find(widget => widget.widgetId === widgetId && widget.widgetNamespace === widgetNamespace);
        if (!existingWidget) {
            return;
        }
        existingWidget.settings = settings ? settings : existingWidget.settings;
        existingWidget.disabled = typeof disabled === 'boolean' ? disabled : existingWidget.disabled;
    }
    removeSidebarWidget(widgetId, widgetNamespace) {
        const currentSidebarWidgets = Array.isArray(this._sidebar) ? this._sidebar : [].concat(sidebarwidget_1.DEFAULT_SIDEBAR_LIST);
        const widgetToDisable = currentSidebarWidgets.find(widget => widget.widgetId === widgetId && widget.widgetNamespace === widgetNamespace);
        if (!widgetToDisable) {
            return;
        }
        this._sidebar = currentSidebarWidgets.filter(widget => widget.widgetId !== widgetId || widget.widgetNamespace !== widgetNamespace);
    }
    resetSidebarToDefault() {
        this._sidebar = undefined;
    }
    resetEditorToDefault() {
        this._editor = undefined;
        this._editors = undefined;
    }
    setEditor(editor) {
        this._editor = editor;
    }
    setEditors(editors) {
        this._editors = editors;
    }
    toAPI() {
        let controls = [];
        lodash_1.forEach(this._controls, (c) => {
            controls.push({
                fieldId: c.fieldId,
                widgetId: c.widgetId,
                settings: c.settings,
                widgetNamespace: c.widgetNamespace
            });
        });
        const result = {
            controls
        };
        if (this._sidebar) {
            result.sidebar = this._sidebar;
        }
        // prefer editors over editor
        if (this._editors) {
            result.editors = this._editors;
        }
        else if (this._editor) {
            result.editor = this._editor;
        }
        return result;
    }
}
exports.EditorInterfaces = EditorInterfaces;
class ContentType {
    constructor(ct) {
        this._id = ct.sys.id;
        this._fields = new Fields(ct.fields);
        this._name = ct.name;
        this._description = ct.description;
        this._version = ct.sys.version;
        this._displayField = ct.displayField;
    }
    get id() {
        return this._id;
    }
    get fields() {
        return this._fields;
    }
    set fields(fields) {
        this._fields = fields;
    }
    get name() {
        return this._name;
    }
    set name(name) {
        this._name = name;
    }
    get description() {
        return this._description;
    }
    set description(description) {
        this._description = description;
    }
    get displayField() {
        return this._displayField;
    }
    set displayField(displayField) {
        this._displayField = displayField;
    }
    get version() {
        return this._version;
    }
    set version(version) {
        this._version = version;
    }
    toAPI() {
        return {
            sys: {
                id: this.id,
                version: this.version
            },
            name: this.name,
            displayField: this.displayField,
            fields: this.fields.toRaw(),
            description: this.description
        };
    }
    clone() {
        return new ContentType(this.toAPI());
    }
}
exports.default = ContentType;
exports.ContentType = ContentType;
//# sourceMappingURL=content-type.js.map