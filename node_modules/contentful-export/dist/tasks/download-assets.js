"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = downloadAssets;

var _path = _interopRequireDefault(require("path"));

var _bluebird = _interopRequireDefault(require("bluebird"));

var _figures = _interopRequireDefault(require("figures"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _request = _interopRequireDefault(require("request"));

var _embargoedAssets = require("../utils/embargoedAssets");

var _getEntityName = _interopRequireDefault(require("contentful-batch-libs/dist/get-entity-name"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function downloadAsset({
  url,
  directory
}) {
  return new _bluebird.default(function (resolve, reject) {
    // handle urls without protocol
    if (url.startsWith('//')) {
      url = 'https:' + url;
    } // build local file path from the url for the download


    const parsedUrl = new URL(url);

    const localFile = _path.default.join(directory, parsedUrl.host, parsedUrl.pathname); // ensure directory exists and create file stream


    _fsExtra.default.mkdirsSync(_path.default.dirname(localFile));

    const file = _fsExtra.default.createWriteStream(localFile); // download asset


    const assetRequest = _request.default.get(url); // pipe response content to file


    assetRequest.on('error', err => {
      reject(err);
    }).on('response', response => {
      if (response.statusCode >= 400) {
        reject(new Error('error response status: ' + response.statusCode));
      }
    }).pipe(file).on('finish', () => resolve(localFile));
  });
}

function downloadAssets(options) {
  return (ctx, task) => {
    let successCount = 0;
    let warningCount = 0;
    let errorCount = 0;
    return _bluebird.default.map(ctx.data.assets, asset => {
      if (!asset.fields.file) {
        task.output = `${_figures.default.warning} asset ${(0, _getEntityName.default)(asset)} has no file(s)`;
        warningCount++;
        return;
      }

      const locales = Object.keys(asset.fields.file);
      return _bluebird.default.mapSeries(locales, locale => {
        const url = asset.fields.file[locale].url;

        if (!url) {
          task.output = `${_figures.default.cross} asset '${(0, _getEntityName.default)(asset)}' doesn't contain an url in path asset.fields.file[${locale}].url`;
          errorCount++;
          return _bluebird.default.resolve();
        }

        let startingPromise = _bluebird.default.resolve({
          url,
          directory: options.exportDir
        });

        if ((0, _embargoedAssets.isEmbargoedAsset)(url)) {
          const {
            host,
            accessToken,
            spaceId,
            environmentId
          } = options;
          const expiresAtMs = (0, _embargoedAssets.calculateExpiryTimestamp)();
          startingPromise = (0, _embargoedAssets.signUrl)(host, accessToken, spaceId, environmentId, url, expiresAtMs).then(signedUrl => ({
            url: signedUrl,
            directory: options.exportDir
          }));
        }

        return startingPromise.then(downloadAsset).then(downLoadedFile => {
          task.output = `${_figures.default.tick} downloaded ${(0, _getEntityName.default)(downLoadedFile)} (${url})`;
          successCount++;
        }).catch(error => {
          task.output = `${_figures.default.cross} error downloading ${url}: ${error.message}`;
          errorCount++;
        });
      });
    }, {
      concurrency: 6
    }).then(() => {
      ctx.assetDownloads = {
        successCount,
        warningCount,
        errorCount
      };
    });
  };
}

module.exports = exports.default;